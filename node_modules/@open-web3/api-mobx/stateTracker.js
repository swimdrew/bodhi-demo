"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _mobx = require("mobx");

var _rpc = _interopRequireDefault(require("./rpc"));

class StateTracker {
  constructor(_ws) {
    this._ws = _ws;
    this._trackKeys = {};
    this._trackPrefixes = {};
    this._callabcksCount = 0;

    this._unsub = () => {};

    this._blockHashAtom = void 0;
    this._blockHash = null;
    this._blockHashAtom = (0, _mobx.createAtom)('block.hash', () => this._incCallabcksCount(), () => this._descCallbacksCount());
  }

  _incCallabcksCount() {
    if (this._callabcksCount === 0) {
      this._unsub = (0, _rpc.default)(this._ws, (err, result) => {
        if (err) {// ignore
        }

        if (result) {
          (0, _mobx.transaction)(() => {
            this._blockHash = result.block;

            this._handleUpdate(result.changes);

            this._blockHashAtom.reportChanged();
          });
        }
      });
    }

    this._callabcksCount++;
  }

  _descCallbacksCount() {
    this._callabcksCount--;

    if (this._callabcksCount === 0) {
      this._unsub();
    }
  }

  _handleUpdate(changeset) {
    for (const [key, value] of changeset) {
      const callbacks = this._trackKeys[key];

      if (callbacks) {
        for (const callback of callbacks) {
          callback(key, value);
        }
      } // TODO: improve this to make it better than O(mn)


      for (const [prefix, prefixCallbacks] of Object.entries(this._trackPrefixes)) {
        if (key.startsWith(prefix)) {
          for (const callback of prefixCallbacks) {
            callback(key, value);
          }
        }
      }
    }
  }

  trackKey(key, callback) {
    let callbacks = this._trackKeys[key];

    if (callbacks == null) {
      callbacks = [];
      this._trackKeys[key] = callbacks;
    }

    callbacks.push(callback);

    this._incCallabcksCount();

    return () => {
      const idx = callbacks.indexOf(callback);

      if (idx !== -1) {
        callbacks.splice(idx, 1);

        this._descCallbacksCount();
      }
    };
  }

  trackPrefix(prefix, callback) {
    let callbacks = this._trackPrefixes[prefix];

    if (callbacks == null) {
      callbacks = [];
      this._trackPrefixes[prefix] = callbacks;
    }

    callbacks.push(callback);

    this._incCallabcksCount();

    return () => {
      const idx = callbacks.indexOf(callback);

      if (idx !== -1) {
        callbacks.splice(idx, 1);

        this._descCallbacksCount();
      }
    };
  }

  get blockHash() {
    this._blockHashAtom.reportObserved();

    return this._blockHash;
  }

}

exports.default = StateTracker;