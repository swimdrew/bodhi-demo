"use strict";

exports.__esModule = true;
exports.ObservableStorageMapEntries = exports.ObservableStorageEntry = void 0;

var _mobx = require("mobx");

var _types = require("@polkadot/types");

var _codec = require("@polkadot/types/codec");

var _util = require("@polkadot/util");

var _getType = require("./getType");

const createMap = name => {
  return _mobx.observable.map({}, {
    deep: false,
    name
  });
};

const isTreatAsHex = key => {
  // :code is problematic - it does not have the length attached, which is
  // unlike all other storage entries where it is indeed properly encoded
  return ['0x3a636f6465'].includes(key);
};

class ObservableStorageEntry {
  constructor(_api, _tracker, _module, _entry, _keys = []) {
    this._api = _api;
    this._tracker = _tracker;
    this._module = _module;
    this._entry = _entry;
    this._keys = _keys;
    this._atom = void 0;
    this._value = null;

    this._unsub = () => {};

    const name = [_module, _entry, ..._keys].join('.');
    this._atom = (0, _mobx.createAtom)(name, () => this._start(), () => this._stop());
  }

  _start() {
    const storageEntry = this._api.query[this._module][this._entry]; // fetch initial value

    storageEntry(...this._keys).then(val => {
      this._value = val;

      this._atom.reportChanged();
    });
    const key = storageEntry.key(...this._keys);
    this._unsub = this._tracker.trackKey(key, (key, value) => {
      const {
        isEmpty,
        fallback,
        modifier
      } = storageEntry.creator.meta;
      const input = isEmpty ? fallback ? (0, _util.hexToU8a)(fallback.toHex()) : undefined : value;

      if (input == null) {
        this._value = null;
      } else {
        const type = (0, _getType.getType)(storageEntry.creator);

        const formatted = this._api.createType(type, isTreatAsHex(key) ? input : (0, _util.u8aToU8a)(input));

        if (modifier.isOptional) {
          this._value = new _codec.Option(this._api.registry, type, formatted);
        } else {
          this._value = formatted;
        }
      }

      this._atom.reportChanged();
    });
  }

  _stop() {
    this._unsub();
  }

  get value() {
    this._atom.reportObserved();

    return this._value;
  }

}

exports.ObservableStorageEntry = ObservableStorageEntry;

class ObservableStorageMapEntries {
  constructor(_api, _tracker, _module, _entry) {
    this._api = _api;
    this._tracker = _tracker;
    this._module = _module;
    this._entry = _entry;
    this._atom = void 0;
    this._value = void 0;

    this._unsub = () => {};

    const name = `${_module}.${_entry}.entries()`;
    this._atom = (0, _mobx.createAtom)(name, () => this._start(), () => this._stop());
    this._value = createMap(name);
  }

  _start() {
    const storageEntry = this._api.query[this._module][this._entry]; // fetch initial value

    storageEntry.entries().then(val => {
      (0, _mobx.transaction)(() => {
        for (const [storageKey, value] of val) {
          const [key1, key2] = storageKey.args.map(i => i.toString());

          if (key2) {
            const name = `${this._module}.${this._entry}.entries().${key1}.${key2}`;
            const values = this._value.get(key1) || createMap(name);
            values.set(key2, value);

            this._value.set(key1, values);
          } else {
            this._value.set(key1, value);
          }
        }
      });
    });
    const prefix = storageEntry.keyPrefix();
    this._unsub = this._tracker.trackPrefix(prefix, (key, value) => {
      const decodedKey = new _types.StorageKey(this._api.registry, key);
      decodedKey.setMeta(storageEntry.creator.meta);
      const [key1, key2] = decodedKey.args.map(i => i.toString());
      const {
        isEmpty,
        fallback,
        modifier
      } = storageEntry.creator.meta;
      const input = isEmpty ? fallback ? (0, _util.hexToU8a)(fallback.toHex()) : undefined : value;

      if (key2) {
        if (input == null) {
          const values = this._value.get(key1);

          if (values) {
            values.delete(key2);

            this._value.set(key1, values);
          }
        } else {
          const name = `${this._module}.${this._entry}.entries().${key1}.${key2}`;
          const values = this._value.get(key1) || createMap(name);
          const type = (0, _getType.getType)(storageEntry.creator);

          const formatted = this._api.createType(type, isTreatAsHex(key) ? input : (0, _util.u8aToU8a)(input));

          if (modifier.isOptional) {
            values.set(key2, new _codec.Option(this._api.registry, type, formatted));
          } else {
            values.set(key2, formatted);
          }

          this._value.set(key1, values);
        }
      } else {
        if (input == null) {
          this._value.delete(key1);
        } else {
          const type = (0, _getType.getType)(storageEntry.creator);

          const formatted = this._api.createType(type, isTreatAsHex(key) ? input : (0, _util.u8aToU8a)(input));

          if (modifier.isOptional) {
            this._value.set(key1, new _codec.Option(this._api.registry, type, formatted));
          } else {
            this._value.set(key1, formatted);
          }
        }
      }
    });
  }

  _stop() {
    this._unsub();
  }

  get value() {
    this._atom.reportObserved();

    return this._value;
  }

}

exports.ObservableStorageMapEntries = ObservableStorageMapEntries;