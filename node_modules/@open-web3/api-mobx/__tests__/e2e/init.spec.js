"use strict";

var _mobx = require("mobx");

var _api = require("@polkadot/api");

var _rpcProvider = require("@polkadot/rpc-provider");

var _ = require("../..");

describe('api-mobx', () => {
  jest.setTimeout(30000);
  let api;
  let storage;
  beforeAll(async () => {
    const ws = new _rpcProvider.WsProvider('wss://kusama-rpc.polkadot.io/');
    api = await _api.ApiPromise.create({
      provider: ws
    });
    storage = (0, _.createStorage)(api, ws);
  });
  it('block hash works', done => {
    (0, _mobx.autorun)(() => {
      const hash = storage.block.hash;
      hash && console.dir(hash);

      if (hash) {
        done();
      }
    });
  });
  it('starts with null', done => {
    let tick = 0;
    (0, _mobx.autorun)(() => {
      const parentHash = storage.system.parentHash;

      if (tick === 0) {
        expect(parentHash).toBeNull();
      } else {
        expect(parentHash).toBeTruthy();
        done();
      }

      tick++;
    });
  });
  it('account works', done => {
    (0, _mobx.autorun)(() => {
      const alice = api.createType('AccountId', 'CtwdfrhECFs3FpvCGoiE4hwRC4UsSiM8WL899HjRdQbfYZY');
      const account = storage.system.account(alice);
      account && console.dir(account.toHuman());

      if (account) {
        done();
      }
    });
  });
  it('StorageMap entries works', done => {
    (0, _mobx.autorun)(() => {
      const validators = storage.staking.validators.entries();
      console.log(validators.keys());
      console.dir([...validators.values()].map(value => value.toHuman()));

      if (validators.size > 0) {
        done();
      }
    });
  });
  it('StorageMap with key works', done => {
    (0, _mobx.autorun)(() => {
      const validator = storage.staking.validators('HYxzaXwkydDNAy3R8UnCvfprNm74TwwSELpyXSRoqmy9AQY');
      validator && console.log(validator.toHuman());

      if (validator) {
        done();
      }
    });
  });
});