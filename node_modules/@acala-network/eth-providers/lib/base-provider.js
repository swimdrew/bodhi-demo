"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseProvider = exports.defaultOpts = void 0;
const eth_transactions_1 = require("@acala-network/eth-transactions");
const abstract_provider_1 = require("@ethersproject/abstract-provider");
const address_1 = require("@ethersproject/address");
const bytes_1 = require("@ethersproject/bytes");
const logger_1 = require("@ethersproject/logger");
const properties_1 = require("@ethersproject/properties");
const providers_1 = require("@ethersproject/providers");
const transactions_1 = require("@ethersproject/transactions");
require("@polkadot/api-augment");
const api_derive_1 = require("@polkadot/api-derive");
const types_1 = require("@polkadot/types");
const util_1 = require("@polkadot/util");
const ethers_1 = require("ethers");
const lru_cache_1 = __importDefault(require("lru-cache"));
const consts_1 = require("./consts");
const utils_1 = require("./utils");
const BlockCache_1 = require("./utils/BlockCache");
const subqlProvider_1 = require("./utils/subqlProvider");
exports.defaultOpts = {
    safeMode: false,
    localMode: false,
    verbose: false,
    subqlUrl: undefined,
    maxBlockCacheSize: 200,
    storageCacheSize: 5000,
    healthCheckBlockDistance: 100
};
const NEW_HEADS = 'newHeads';
const NEW_LOGS = 'logs';
const ALL_EVENTS = [NEW_HEADS, NEW_LOGS];
class BaseProvider extends abstract_provider_1.Provider {
    constructor({ safeMode = false, localMode = false, verbose = false, subqlUrl, maxBlockCacheSize = 200, storageCacheSize = 5000, healthCheckBlockDistance = 100 } = exports.defaultOpts) {
        super();
        this.storages = new WeakMap();
        this.startSubscription = async () => {
            this._cache = new BlockCache_1.BlockCache(this.maxBlockCacheSize);
            if (this.maxBlockCacheSize < 1) {
                return utils_1.logger.throwError(`expect maxBlockCacheSize > 0, but got ${this.maxBlockCacheSize}`, logger_1.Logger.errors.INVALID_ARGUMENT);
            }
            else {
                this.maxBlockCacheSize > 9999 && utils_1.logger.warn(consts_1.CACHE_SIZE_WARNING);
            }
            await this.isReady();
            const subscriptionMethod = this.safeMode
                ? this.api.rpc.chain.subscribeFinalizedHeads.bind(this)
                : this.api.rpc.chain.subscribeNewHeads.bind(this);
            subscriptionMethod(async (header) => {
                // cache
                const blockNumber = header.number.toNumber();
                const blockHash = (await this.api.rpc.chain.getBlockHash(blockNumber)).toHex();
                const txHashes = await this._getTxHashesAtBlock(blockHash);
                this._cache.addTxsAtBlock(blockNumber, txHashes);
                // eth_subscribe
                // TODO: can do some optimizations
                if (this._listeners[NEW_HEADS]?.length > 0) {
                    const block = await this.getBlockData(blockNumber, false);
                    const response = (0, utils_1.hexlifyRpcResult)(block);
                    this._listeners[NEW_HEADS].forEach((l) => l.cb(response));
                }
                if (this._listeners[NEW_LOGS]?.length > 0) {
                    const block = await this.getBlockData(header.number.toHex(), false);
                    const receipts = await Promise.all(block.transactions.map((tx) => this.getTransactionReceiptAtBlock(tx, header.number.toHex())));
                    const logs = receipts.map((r) => r.logs).flat();
                    this._listeners[NEW_LOGS]?.forEach(({ cb, filter }) => {
                        const filteredLogs = logs.filter((l) => (0, utils_1.filterLog)(l, filter));
                        const response = (0, utils_1.hexlifyRpcResult)(filteredLogs);
                        response.forEach((log) => cb(log));
                    });
                }
            });
            // for getTXhashFromNextBlock
            this.api.rpc.chain.subscribeNewHeads((header) => {
                this._newBlockListeners.forEach((cb) => {
                    try {
                        cb(header);
                    }
                    catch {
                        /* swallow */
                    }
                });
                this._newBlockListeners = [];
            });
            this.api.rpc.chain.subscribeFinalizedHeads(async (header) => {
                const blockNumber = header.number.toNumber();
                this.latestFinalizedBlockNumber = blockNumber;
                // safe mode only, if useful in the future, can remove this if condition
                if (this.safeMode) {
                    const blockHash = (await this.api.rpc.chain.getBlockHash(blockNumber)).toHex();
                    this.latestFinalizedBlockHash = blockHash;
                }
            });
            this.api.rpc.state.subscribeRuntimeVersion((runtime) => {
                const version = runtime.specVersion.toNumber();
                this.verbose && utils_1.logger.info(`runtime version: ${version}`);
                if (!this.runtimeVersion || this.runtimeVersion === version) {
                    this.runtimeVersion = version;
                }
                else {
                    utils_1.logger.warn(`runtime version changed: ${this.runtimeVersion} => ${version}, shutting down myself... good bye ðŸ‘‹`);
                    process?.exit(1);
                }
            });
        };
        this.setApi = (api) => {
            (0, properties_1.defineReadOnly)(this, '_api', api);
        };
        this.queryStorage = async (module, args, _blockTag) => {
            const blockTag = await this._ensureSafeModeBlockTagFinalization(_blockTag);
            const blockHash = await this._getBlockHash(blockTag);
            const registry = await this.api.getBlockRegistry((0, util_1.u8aToU8a)(blockHash));
            if (!this.storages.get(registry)) {
                const storage = (0, types_1.decorateStorage)(registry.registry, registry.metadata.asLatest, registry.metadata.version);
                this.storages.set(registry, storage);
            }
            const storage = this.storages.get(registry);
            const [section, method] = module.split('.');
            const entry = storage[section][method];
            const key = entry(...args);
            const outputType = (0, types_1.unwrapStorageType)(registry.registry, entry.meta.type, entry.meta.modifier.isOptional);
            const cacheKey = `${module}-${blockHash}-${args.join(',')}`;
            const cached = this._storageCache.get(cacheKey);
            let input = null;
            if (cached) {
                input = cached;
            }
            else {
                const value = await this.api.rpc.state.getStorage(key, blockHash);
                const isEmpty = (0, util_1.isNull)(value);
                // we convert to Uint8Array since it maps to the raw encoding, all
                // data will be correctly encoded (incl. numbers, excl. :code)
                input = isEmpty
                    ? null
                    : (0, util_1.u8aToU8a)(entry.meta.modifier.isOptional ? value.toU8a() : value.isSome ? value.unwrap().toU8a() : null);
                this._storageCache.set(cacheKey, input);
            }
            const result = registry.registry.createTypeUnsafe(outputType, [input], {
                blockHash,
                isPedantic: !entry.meta.modifier.isOptional
            });
            return result;
        };
        this.isReady = () => {
            if (!this._network) {
                const _getNetwork = async () => {
                    try {
                        await this.api.isReadyOrError;
                        const network = {
                            name: this.api.runtimeVersion.specName.toString(),
                            chainId: await this.chainId()
                        };
                        return network;
                    }
                    catch (e) {
                        await this.api.disconnect();
                        throw e;
                    }
                };
                this._network = _getNetwork();
            }
            return this._network;
        };
        this.disconnect = async () => {
            await this.api.disconnect();
        };
        this.getNetwork = async () => {
            const network = await this.isReady();
            return network;
        };
        this.netVersion = async () => {
            return this.api.consts.evmAccounts.chainId.toString();
        };
        this.chainId = async () => {
            await this.api.isReadyOrError;
            return this.api.consts.evmAccounts.chainId.toNumber();
        };
        this.getBlockNumber = async () => {
            await this.getNetwork();
            const header = await this._getBlockHeader('latest');
            return header.number.toNumber();
        };
        this._getBlock = async (_blockTag) => {
            await this.getNetwork();
            const blockTag = await this._ensureSafeModeBlockTagFinalization(_blockTag);
            const header = await this._getBlockHeader(blockTag);
            const blockHash = header.hash.toHex();
            const [block, validators, now, blockEvents] = await Promise.all([
                this.api.rpc.chain.getBlock(blockHash),
                this.api.query.session ? this.queryStorage('session.validators', [], blockHash) : [],
                this.queryStorage('timestamp.now', [], blockHash),
                this.queryStorage('system.events', [], blockHash)
            ]);
            const headerExtended = (0, api_derive_1.createHeaderExtended)(header.registry, header, validators);
            const blockNumber = headerExtended.number.toNumber();
            // blockscout need `toLowerCase`
            const author = headerExtended.author
                ? (await this.getEvmAddress(headerExtended.author.toString())).toLowerCase()
                : consts_1.DUMMY_ADDRESS;
            const evmExtrinsicIndexes = (0, utils_1.getEvmExtrinsicIndexes)(blockEvents);
            const transactions = evmExtrinsicIndexes.map((extrinsicIndex) => block.block.extrinsics[extrinsicIndex].hash.toHex());
            return {
                hash: blockHash,
                parentHash: headerExtended.parentHash.toHex(),
                number: blockNumber,
                stateRoot: headerExtended.stateRoot.toHex(),
                transactionsRoot: headerExtended.extrinsicsRoot.toHex(),
                timestamp: Math.floor(now.toNumber() / 1000),
                nonce: consts_1.DUMMY_BLOCK_NONCE,
                mixHash: consts_1.DUMMY_BLOCK_MIX_HASH,
                difficulty: consts_1.ZERO,
                totalDifficulty: consts_1.ZERO,
                gasLimit: ethers_1.BigNumber.from(15000000),
                gasUsed: consts_1.BIGNUMBER_ZERO,
                miner: author,
                extraData: consts_1.EMPTY_HEX_STRING,
                sha3Uncles: consts_1.EMTPY_UNCLE_HASH,
                receiptsRoot: headerExtended.extrinsicsRoot.toHex(),
                logsBloom: consts_1.DUMMY_LOGS_BLOOM,
                size: block.encodedLength,
                uncles: consts_1.EMTPY_UNCLES,
                transactions
            };
        };
        this._getFullBlock = async (blockTag) => {
            const block = await this._getBlock(blockTag);
            const transactions = await Promise.all(block.transactions.map((txHash) => this.getTransactionByHash(txHash)));
            const gasUsed = transactions.reduce((r, tx) => r.add(tx.gas), consts_1.BIGNUMBER_ZERO);
            return {
                ...block,
                transactions,
                gasUsed
            };
        };
        this.getBlockData = async (blockTag, full) => {
            return full
                ? (await this._getFullBlock(blockTag))
                : (await this._getBlock(blockTag));
        };
        this.getBlock = async (blockHashOrBlockTag) => (0, utils_1.throwNotImplemented)('getBlock (please use `getBlockData` instead)');
        this.getBlockWithTransactions = async (blockHashOrBlockTag) => (0, utils_1.throwNotImplemented)('getBlockWithTransactions (please use `getBlockData` instead)');
        this.getBalance = async (addressOrName, _blockTag) => {
            await this.getNetwork();
            const blockTag = await this._ensureSafeModeBlockTagFinalization(_blockTag);
            const { address, blockHash } = await (0, properties_1.resolveProperties)({
                address: this._getAddress(addressOrName),
                blockHash: this._getBlockHash(blockTag)
            });
            const substrateAddress = await this.getSubstrateAddress(address, blockHash);
            const accountInfo = await this.queryStorage('system.account', [substrateAddress], blockHash);
            return (0, utils_1.nativeToEthDecimal)(accountInfo.data.free.toBigInt(), this.chainDecimal);
        };
        this.getTransactionCount = async (addressOrName, blockTag) => {
            return this.getEvmTransactionCount(addressOrName, blockTag);
        };
        // TODO: test pending
        this.getEvmTransactionCount = async (addressOrName, blockTag) => {
            await this.getNetwork();
            const accountInfo = await this.queryAccountInfo(addressOrName, blockTag);
            let pendingNonce = 0;
            if ((await blockTag) === 'pending') {
                const [substrateAddress, pendingExtrinsics] = await Promise.all([
                    this.getSubstrateAddress(await addressOrName),
                    this.api.rpc.author.pendingExtrinsics()
                ]);
                pendingNonce = pendingExtrinsics.filter((e) => (0, utils_1.isEVMExtrinsic)(e) && e.signer.toString() === substrateAddress).length;
            }
            const minedNonce = !accountInfo.isNone ? accountInfo.unwrap().nonce.toNumber() : 0;
            return minedNonce + pendingNonce;
        };
        this.getSubstrateNonce = async (addressOrName, blockTag) => {
            await this.getNetwork();
            const address = await this._getAddress(addressOrName);
            const resolvedBlockTag = await blockTag;
            const substrateAddress = await this.getSubstrateAddress(address);
            if (resolvedBlockTag === 'pending') {
                const idx = await this.api.rpc.system.accountNextIndex(substrateAddress);
                return idx.toNumber();
            }
            const blockHash = await this._getBlockHash(blockTag);
            const accountInfo = await this.queryStorage('system.account', [substrateAddress], blockHash);
            return accountInfo.nonce.toNumber();
        };
        this.getCode = async (addressOrName, _blockTag) => {
            await this.getNetwork();
            const blockTag = await this._ensureSafeModeBlockTagFinalization(_blockTag);
            if ((await blockTag) === 'pending')
                return '0x';
            const { address, blockHash } = await (0, properties_1.resolveProperties)({
                address: this._getAddress(addressOrName),
                blockHash: this._getBlockHash(blockTag)
            });
            const contractInfo = await this.queryContractInfo(address, blockHash);
            if (contractInfo.isNone) {
                return '0x';
            }
            const codeHash = contractInfo.unwrap().codeHash;
            const api = await (blockHash ? this.api.at(blockHash) : this.api);
            const code = await api.query.evm.codes(codeHash);
            return code.toHex();
        };
        this.call = async (transaction, _blockTag) => {
            await this.getNetwork();
            const blockTag = await this._ensureSafeModeBlockTagFinalization(_blockTag);
            const resolved = await (0, properties_1.resolveProperties)({
                transaction: this._getTransactionRequest(transaction),
                blockHash: this._getBlockHash(blockTag)
            });
            const callRequest = {
                from: resolved.transaction.from,
                to: resolved.transaction.to,
                gasLimit: resolved.transaction.gasLimit?.toBigInt(),
                storageLimit: undefined,
                value: resolved.transaction.value?.toBigInt(),
                data: resolved.transaction.data,
                accessList: resolved.transaction.accessList
            };
            const data = resolved.blockHash
                ? await this.api.rpc.evm.call(callRequest, resolved.blockHash)
                : await this.api.rpc.evm.call(callRequest);
            return data.toHex();
        };
        this.getStorageAt = async (addressOrName, position, _blockTag) => {
            await this.getNetwork();
            const blockTag = await this._ensureSafeModeBlockTagFinalization(_blockTag);
            // @TODO resolvedPosition
            // eslint-disable-next-line
            const { address, blockHash, resolvedPosition } = await (0, properties_1.resolveProperties)({
                address: this._getAddress(addressOrName),
                blockHash: this._getBlockHash(blockTag),
                resolvedPosition: Promise.resolve(position).then((p) => (0, bytes_1.hexValue)(p))
            });
            const code = await this.queryStorage('evm.accountStorages', [address, position], blockHash);
            return code.toHex();
        };
        // @TODO
        this.resolveName = async (name) => {
            name = await name;
            return name;
            // If it is already an address, nothing to resolve
            // try {
            //   return Promise.resolve(this.formatter.address(name));
            // } catch (error) {
            //   // If is is a hexstring, the address is bad (See #694)
            //   if (isHexString(name)) {
            //     throw error;
            //   }
            // }
            // if (typeof name !== 'string') {
            //   logger.throwArgumentError('invalid ENS name', 'name', name);
            // }
            // // Get the addr from the resovler
            // const resolver = await this.getResolver(name);
            // if (!resolver) {
            //   return null;
            // }
            // return await resolver.getAddress();
        };
        this.getGasPrice = async () => {
            // tx_fee_per_gas + (current_block / 30 + 5) << 16 + 10
            const txFeePerGas = ethers_1.BigNumber.from(this.api.consts.evm.txFeePerGas.toBigInt());
            const currentHeader = await this.api.rpc.chain.getHeader();
            const currentBlockNumber = ethers_1.BigNumber.from(currentHeader.number.toBigInt());
            return txFeePerGas.add(currentBlockNumber.div(30).add(5).shl(16)).add(10);
        };
        this.getFeeData = async () => {
            return {
                maxFeePerGas: null,
                maxPriorityFeePerGas: null,
                gasPrice: await this.getGasPrice()
            };
        };
        this._getGasConsts = () => ({
            storageDepositPerByte: this.api.consts.evm.storageDepositPerByte.toBigInt(),
            txFeePerGas: this.api.consts.evm.txFeePerGas.toBigInt()
        });
        /**
         * Estimate gas for a transaction.
         * @param transaction The transaction to estimate the gas of
         * @returns The estimated gas used by this transaction
         */
        this.estimateGas = async (transaction) => {
            await this.call(transaction);
            const { storageDepositPerByte, txFeePerGas } = this._getGasConsts();
            const gasPrice = (await transaction.gasPrice) || (await this.getGasPrice());
            const storageEntryLimit = ethers_1.BigNumber.from(gasPrice).and(0xffff);
            const storageEntryDeposit = ethers_1.BigNumber.from(storageDepositPerByte).mul(64);
            const storageGasLimit = storageEntryLimit.mul(storageEntryDeposit).div(txFeePerGas);
            const resources = await this.estimateResources(transaction);
            return resources.gas.add(storageGasLimit);
        };
        /**
         * Get the gas for eth transactions
         * @returns The gas used by eth transaction
         */
        this.getEthResources = async (transaction, { gasLimit, storageLimit, validUntil } = {}) => {
            if (!gasLimit || !storageLimit) {
                const { gas, storage } = await this.estimateResources(transaction);
                gasLimit = gasLimit ?? gas;
                storageLimit = storageLimit ?? storage;
            }
            if (!validUntil) {
                const blockNumber = await this.getBlockNumber();
                // Expires after 100 blocks by default
                validUntil = blockNumber + 100;
            }
            const storageByteDeposit = this.api.consts.evm.storageDepositPerByte.toBigInt();
            const txFeePerGas = this.api.consts.evm.txFeePerGas.toBigInt();
            const { txGasLimit, txGasPrice } = (0, utils_1.calcEthereumTransactionParams)({
                gasLimit,
                storageLimit,
                validUntil,
                storageByteDeposit,
                txFeePerGas
            });
            return {
                gasLimit: txGasLimit,
                gasPrice: txGasPrice
            };
        };
        /**
         * helper to get ETH gas when don't know the whole transaction
         * default to return big enough gas for contract deployment
         * @returns The gas used by eth transaction
         */
        this._getEthGas = async ({ gasLimit = 21000000, storageLimit = 64100, validUntil: _validUntil } = {}) => {
            const validUntil = _validUntil || (await this.getBlockNumber()) + 150; // default 150 * 12 / 60 = 30min
            const storageByteDeposit = this.api.consts.evm.storageDepositPerByte.toBigInt();
            const txFeePerGas = this.api.consts.evm.txFeePerGas.toBigInt();
            const { txGasLimit, txGasPrice } = (0, utils_1.calcEthereumTransactionParams)({
                gasLimit,
                storageLimit,
                validUntil,
                storageByteDeposit,
                txFeePerGas
            });
            return {
                gasLimit: txGasLimit,
                gasPrice: txGasPrice
            };
        };
        /**
         * Validate substrate transaction parameters
         */
        this.validSubstrateResources = ({ gasLimit, gasPrice }) => {
            const storageByteDeposit = this.api.consts.evm.storageDepositPerByte.toBigInt();
            const txFeePerGas = this.api.consts.evm.txFeePerGas.toBigInt();
            return (0, utils_1.calcSubstrateTransactionParams)({
                txGasPrice: gasPrice,
                txGasLimit: gasLimit,
                storageByteDeposit,
                txFeePerGas
            });
        };
        /**
         * Estimate resources for a transaction.
         * @param transaction The transaction to estimate the resources of
         * @returns The estimated resources used by this transaction
         */
        this.estimateResources = async (transaction) => {
            const ethTx = await this._getTransactionRequest(transaction);
            const { from, to, data, value } = ethTx;
            const accessList = ethTx.accessList?.map(({ address, storageKeys }) => [address, storageKeys]) || [];
            const extrinsic = !to
                ? this.api.tx.evm.create(data, value?.toBigInt(), consts_1.U64MAX.toBigInt(), // gas_limit u64::max
                consts_1.U32MAX.toBigInt(), // storage_limit u32::max
                // @ts-ignore @TODO fix type
                accessList)
                : this.api.tx.evm.call(to, data, value?.toBigInt(), consts_1.U64MAX.toBigInt(), // gas_limit u64::max
                consts_1.U32MAX.toBigInt(), // storage_limit u32::max
                // @ts-ignore @TODO fix type
                accessList);
            const result = await this.api.rpc.evm.estimateResources(from, extrinsic.toHex());
            return {
                gas: ethers_1.BigNumber.from(result.gas.toString()),
                storage: ethers_1.BigNumber.from(result.storage.toString()),
                weightFee: ethers_1.BigNumber.from(result.weightFee.toString())
            };
        };
        this.getSubstrateAddress = async (addressOrName, blockTag) => {
            const { address, blockHash } = await (0, properties_1.resolveProperties)({
                address: this._getAddress(addressOrName),
                blockHash: this._getBlockHash(blockTag)
            });
            const substrateAccount = await this.queryStorage('evmAccounts.accounts', [address], blockHash);
            return substrateAccount.isEmpty ? (0, utils_1.computeDefaultSubstrateAddress)(address) : substrateAccount.toString();
        };
        this.getEvmAddress = async (substrateAddress, blockTag) => {
            substrateAddress = await substrateAddress;
            const { blockHash } = await (0, properties_1.resolveProperties)({
                blockHash: this._getBlockHash(blockTag)
            });
            const apiAt = await this.api.at(blockHash);
            const evmAddress = await apiAt.query.evmAccounts.evmAddresses(substrateAddress);
            return (0, address_1.getAddress)(evmAddress.isEmpty ? (0, utils_1.computeDefaultEvmAddress)(substrateAddress) : evmAddress.toString());
        };
        this.queryAccountInfo = async (addressOrName, _blockTag) => {
            const blockTag = await this._ensureSafeModeBlockTagFinalization(_blockTag);
            // pending tag
            const resolvedBlockTag = await blockTag;
            if (resolvedBlockTag === 'pending') {
                const address = await this._getAddress(addressOrName);
                return this.api.query.evm.accounts(address);
            }
            const { address, blockHash } = await (0, properties_1.resolveProperties)({
                address: this._getAddress(addressOrName),
                blockHash: this._getBlockHash(blockTag)
            });
            const accountInfo = await this.queryStorage('evm.accounts', [address], blockHash);
            return accountInfo;
        };
        this.queryContractInfo = async (addressOrName, blockTag) => {
            const accountInfo = await this.queryAccountInfo(addressOrName, blockTag);
            if (accountInfo.isNone) {
                return this.api.createType('Option<EvmContractInfo>', null);
            }
            return accountInfo.unwrap().contractInfo;
        };
        this._getSubstrateGasParams = (ethTx) => {
            let gasLimit = 0n;
            let storageLimit = 0n;
            let validUntil = 0n;
            let tip = 0n;
            if (ethTx.type === 96) {
                // EIP-712 transaction
                const _storageLimit = ethTx.storageLimit?.toString();
                const _validUntil = ethTx.validUntil?.toString();
                const _tip = ethTx.tip?.toString();
                if (!_storageLimit) {
                    return utils_1.logger.throwError('expect storageLimit');
                }
                if (!_validUntil) {
                    return utils_1.logger.throwError('expect validUntil');
                }
                if (!_tip) {
                    return utils_1.logger.throwError('expect priorityFee');
                }
                gasLimit = ethTx.gasLimit.toBigInt();
                storageLimit = BigInt(_storageLimit);
                validUntil = BigInt(_validUntil);
                tip = BigInt(_tip);
            }
            else if (ethTx.type === null || ethTx.type === undefined || ethTx.type === 0 || ethTx.type === 2) {
                // Legacy, EIP-155, and EIP-1559 transaction
                const { storageDepositPerByte, txFeePerGas } = this._getGasConsts();
                const _getErrInfo = () => ({
                    txGasLimit: ethTx.gasLimit.toBigInt(),
                    txGasPrice: ethTx.gasPrice?.toBigInt(),
                    maxPriorityFeePerGas: ethTx.maxPriorityFeePerGas?.toBigInt(),
                    maxFeePerGas: ethTx.maxFeePerGas?.toBigInt(),
                    txFeePerGas,
                    storageDepositPerByte
                });
                const err_help_msg = 'invalid ETH gasLimit/gasPrice combination provided. Please DO NOT change gasLimit/gasPrice in metamask when sending token, if you are deploying contract, DO NOT provide random gasLimit/gasPrice, please check out our doc for how to compute gas, easiest way is to call eth_getEthGas directly';
                try {
                    const params = (0, utils_1.calcSubstrateTransactionParams)({
                        txGasPrice: ethTx.maxFeePerGas || ethTx.gasPrice || '0',
                        txGasLimit: ethTx.gasLimit || '0',
                        storageByteDeposit: storageDepositPerByte,
                        txFeePerGas: txFeePerGas
                    });
                    gasLimit = params.gasLimit.toBigInt();
                    validUntil = params.validUntil.toBigInt();
                    storageLimit = params.storageLimit.toBigInt();
                    tip = (ethTx.maxPriorityFeePerGas?.toBigInt() || 0n) * gasLimit;
                }
                catch {
                    utils_1.logger.throwError(`calculating substrate gas failed: ${err_help_msg}`, logger_1.Logger.errors.INVALID_ARGUMENT, _getErrInfo());
                }
                if (gasLimit < 0n || validUntil < 0n || storageLimit < 0n) {
                    utils_1.logger.throwError(`bad substrate gas params caused by ${err_help_msg}`, logger_1.Logger.errors.INVALID_ARGUMENT, {
                        ..._getErrInfo(),
                        gasLimit,
                        validUntil,
                        storageLimit
                    });
                }
            }
            else if (ethTx.type === 1) {
                // EIP-2930 transaction
                return (0, utils_1.throwNotImplemented)('EIP-2930 transactions');
            }
            const accessList = ethTx.accessList?.map((set) => [set.address, set.storageKeys]);
            return {
                gasLimit,
                storageLimit,
                validUntil,
                tip,
                accessList
            };
        };
        this.prepareTransaction = async (rawTx) => {
            await this.getNetwork();
            const signatureType = (0, eth_transactions_1.checkSignatureType)(rawTx);
            const ethTx = (0, eth_transactions_1.parseTransaction)(rawTx);
            if (!ethTx.from) {
                return utils_1.logger.throwError('missing from address', logger_1.Logger.errors.INVALID_ARGUMENT, ethTx);
            }
            const { storageLimit, validUntil, gasLimit, tip, accessList } = this._getSubstrateGasParams(ethTx);
            // check excuted error
            const callRequest = {
                from: ethTx.from,
                // @TODO Support create
                to: ethTx.to,
                gasLimit: gasLimit,
                storageLimit: storageLimit,
                value: ethTx.value.toString(),
                data: ethTx.data,
                accessList: ethTx.accessList
            };
            await this.api.rpc.evm.call(callRequest);
            const extrinsic = this.api.tx.evm.ethCall(ethTx.to ? { Call: ethTx.to } : { Create: null }, ethTx.data, ethTx.value.toString(), gasLimit, storageLimit, 
            // @ts-ignore @TODO fix type
            accessList || [], validUntil);
            const subAddr = await this.getSubstrateAddress(ethTx.from);
            const sig = (0, bytes_1.joinSignature)({ r: ethTx.r, s: ethTx.s, v: ethTx.v });
            extrinsic.addSignature(subAddr, { [signatureType]: sig }, {
                blockHash: '0x',
                era: '0x00',
                genesisHash: '0x',
                method: 'Bytes',
                specVersion: 0,
                transactionVersion: 0,
                nonce: ethTx.nonce,
                tip
            });
            utils_1.logger.debug({
                evmAddr: ethTx.from,
                address: subAddr,
                hash: extrinsic.hash.toHex()
            }, 'sending raw transaction');
            return {
                extrinsic,
                transaction: ethTx
            };
        };
        this.sendRawTransaction = async (rawTx) => {
            const { extrinsic } = await this.prepareTransaction(rawTx);
            await extrinsic.send();
            return extrinsic.hash.toHex();
        };
        this.sendTransaction = async (signedTransaction) => {
            await this.getNetwork();
            const hexTx = await Promise.resolve(signedTransaction).then((t) => (0, bytes_1.hexlify)(t));
            const tx = (0, eth_transactions_1.parseTransaction)(await signedTransaction);
            if (tx.confirmations === null || tx.confirmations === undefined) {
                tx.confirmations = 0;
            }
            try {
                const { extrinsic, transaction } = await this.prepareTransaction(hexTx);
                //@TODO
                // wait for tx in block
                const result = await (0, utils_1.sendTx)(this.api, extrinsic);
                const blockHash = result.status.isInBlock ? result.status.asInBlock : result.status.asFinalized;
                const header = await this._getBlockHeader(blockHash.toHex());
                const blockNumber = header.number.toNumber();
                const hash = extrinsic.hash.toHex();
                return this._wrapTransaction(transaction, hash, blockNumber, blockHash.toHex());
            }
            catch (err) {
                const error = err;
                for (const pattern of consts_1.ERROR_PATTERN) {
                    const match = (error.toString?.() || '').match(pattern);
                    if (match) {
                        const errDetails = this.api.registry.findMetaError(new Uint8Array([parseInt(match[1]), parseInt(match[2])]));
                        // error.message is readonly, so construct a new error object
                        throw new Error(JSON.stringify({
                            message: `${errDetails.section}.${errDetails.name}: ${errDetails.docs}`,
                            transaction: tx,
                            transactionHash: tx.hash
                        }));
                    }
                }
                error.transaction = tx;
                error.transactionHash = tx.hash;
                throw error;
            }
        };
        this._wrapTransaction = async (tx, hash, startBlock, startBlockHash) => {
            if (hash !== null && hash !== undefined && (0, bytes_1.hexDataLength)(hash) !== 32) {
                throw new Error('invalid hash - sendTransaction');
            }
            // Check the hash we expect is the same as the hash the server reported
            // @TODO expectedHash
            // if (hash != null && tx.hash !== hash) {
            //   logger.throwError('Transaction hash mismatch from Provider.sendTransaction.', Logger.errors.UNKNOWN_ERROR, {
            //     expectedHash: tx.hash,
            //     returnedHash: hash
            //   });
            // }
            const result = tx;
            // fix tx hash
            result.hash = hash;
            result.blockNumber = startBlock;
            result.blockHash = startBlockHash;
            result.timestamp = Math.floor((await this.queryStorage('timestamp.now', [], result.blockHash)).toNumber() / 1000);
            result.wait = async (confirms, timeout) => {
                if (confirms === null || confirms === undefined) {
                    confirms = 1;
                }
                if (timeout === null || timeout === undefined) {
                    timeout = 0;
                }
                return new Promise((resolve, reject) => {
                    const cancelFuncs = [];
                    let done = false;
                    const alreadyDone = function () {
                        if (done) {
                            return true;
                        }
                        done = true;
                        cancelFuncs.forEach((func) => {
                            func();
                        });
                        return false;
                    };
                    this.api.rpc.chain
                        .subscribeNewHeads((head) => {
                        const blockNumber = head.number.toNumber();
                        if (confirms <= blockNumber - startBlock + 1) {
                            const receipt = this.getTransactionReceiptAtBlock(hash, startBlockHash);
                            if (alreadyDone()) {
                                return;
                            }
                            resolve(receipt);
                        }
                    })
                        .then((unsubscribe) => {
                        cancelFuncs.push(() => {
                            unsubscribe();
                        });
                    })
                        .catch((error) => {
                        reject(error);
                    });
                    if (typeof timeout === 'number' && timeout > 0) {
                        const timer = setTimeout(() => {
                            if (alreadyDone()) {
                                return;
                            }
                            reject(utils_1.logger.makeError('timeout exceeded', logger_1.Logger.errors.TIMEOUT, { timeout: timeout }));
                        }, timeout);
                        if (timer.unref) {
                            timer.unref();
                        }
                        cancelFuncs.push(() => {
                            clearTimeout(timer);
                        });
                    }
                });
            };
            return result;
        };
        this._getBlockHash = async (_blockTag) => {
            const blockTag = (await _blockTag) || 'latest';
            switch (blockTag) {
                case 'pending': {
                    return utils_1.logger.throwError('pending tag not implemented', logger_1.Logger.errors.UNSUPPORTED_OPERATION);
                }
                case 'latest': {
                    return this.safeMode ? this.latestFinalizedBlockHash : (await this.api.rpc.chain.getBlockHash()).toHex();
                }
                case 'earliest': {
                    const hash = this.api.genesisHash;
                    return hash.toHex();
                }
                default: {
                    let blockHash = undefined;
                    if ((0, bytes_1.isHexString)(blockTag, 32)) {
                        blockHash = blockTag;
                    }
                    else if ((0, bytes_1.isHexString)(blockTag) || typeof blockTag === 'number') {
                        const blockNumber = ethers_1.BigNumber.from(blockTag);
                        // max blockNumber is u32
                        if (blockNumber.gt(0xffffffff)) {
                            return utils_1.logger.throwArgumentError('block number should be less than u32', 'blockNumber', blockNumber);
                        }
                        const isFinalized = this.latestFinalizedBlockNumber && blockNumber.lte(this.latestFinalizedBlockNumber);
                        const cacheKey = `blockHash-${blockNumber.toString()}`;
                        if (isFinalized) {
                            const cached = this._storageCache.get(cacheKey);
                            if (cached) {
                                return (0, util_1.u8aToHex)(cached);
                            }
                        }
                        const _blockHash = await this.api.rpc.chain.getBlockHash(blockNumber.toBigInt());
                        if (_blockHash.isEmpty) {
                            //@ts-ignore
                            return utils_1.logger.throwError('header not found', utils_1.PROVIDER_ERRORS.HEADER_NOT_FOUND);
                        }
                        blockHash = _blockHash.toHex();
                        if (isFinalized) {
                            this._storageCache.set(cacheKey, _blockHash.toU8a());
                        }
                    }
                    if (!blockHash) {
                        return utils_1.logger.throwArgumentError('blocktag should be a hex string or number', 'blockTag', blockTag);
                    }
                    return blockHash;
                }
            }
        };
        this._isBlockFinalized = async (blockTag) => {
            let isFinalized = false;
            const [finalizedHead, verifyingBlockHash] = await Promise.all([
                this.api.rpc.chain.getFinalizedHead(),
                this._getBlockHash(blockTag)
            ]);
            const [finalizedBlockNumber, verifyingBlockNumber] = (await Promise.all([this.api.rpc.chain.getHeader(finalizedHead), this.api.rpc.chain.getHeader(verifyingBlockHash)])).map((header) => header.number.toNumber());
            if (finalizedBlockNumber >= verifyingBlockNumber) {
                const canonicalHash = await this.api.rpc.chain.getBlockHash(verifyingBlockNumber);
                isFinalized = canonicalHash.toString() === verifyingBlockHash;
            }
            return isFinalized;
        };
        this._isTransactionFinalized = async (txHash) => {
            const tx = await this._getMinedTXReceipt(txHash);
            if (!tx)
                return false;
            return await this._isBlockFinalized(tx.blockHash);
        };
        this._ensureSafeModeBlockTagFinalization = async (_blockTag) => {
            if (!this.safeMode || !_blockTag)
                return _blockTag;
            const blockTag = await _blockTag;
            if (blockTag === 'latest')
                return this.latestFinalizedBlockHash;
            const isBlockFinalized = await this._isBlockFinalized(blockTag);
            return isBlockFinalized
                ? blockTag
                : // We can also throw header not found error here, which is more consistent with actual block not found error. However, This error is more informative.
                    utils_1.logger.throwError('SAFE MODE ERROR: target block is not finalized', logger_1.Logger.errors.UNKNOWN_ERROR, { blockTag });
        };
        this._getBlockHeader = async (blockTag) => {
            const blockHash = await this._getBlockHash(blockTag);
            try {
                const header = await this.api.rpc.chain.getHeader(blockHash);
                return header;
            }
            catch (error) {
                if (typeof error === 'object' &&
                    typeof error.message === 'string' &&
                    error.message.match(/Unable to retrieve header and parent from supplied hash/gi)) {
                    //@ts-ignore
                    return utils_1.logger.throwError('header not found', utils_1.PROVIDER_ERRORS.HEADER_NOT_FOUND);
                }
                throw error;
            }
        };
        this._getAddress = async (addressOrName) => {
            addressOrName = await addressOrName;
            return addressOrName;
        };
        this._getTransactionRequest = async (transaction) => {
            const values = await transaction;
            const tx = {};
            ['from', 'to'].forEach((key) => {
                if (values[key] === null || values[key] === undefined) {
                    return;
                }
                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));
            });
            ['gasLimit', 'gasPrice', 'maxFeePerGas', 'maxPriorityFeePerGas', 'value'].forEach((key) => {
                if (values[key] === null || values[key] === undefined) {
                    return;
                }
                tx[key] = Promise.resolve(values[key]).then((v) => (v ? ethers_1.BigNumber.from(v) : null));
            });
            ['type'].forEach((key) => {
                if (values[key] === null || values[key] === undefined) {
                    return;
                }
                tx[key] = Promise.resolve(values[key]).then((v) => (v !== null || v !== undefined ? v : null));
            });
            if (values.accessList) {
                tx.accessList = (0, transactions_1.accessListify)(values.accessList);
            }
            ['data'].forEach((key) => {
                if (values[key] === null || values[key] === undefined) {
                    return;
                }
                tx[key] = Promise.resolve(values[key]).then((v) => (v ? (0, bytes_1.hexlify)(v) : null));
            });
            return await (0, properties_1.resolveProperties)(tx);
        };
        this._getTxHashesAtBlock = async (blockHash) => {
            const block = await this.api.rpc.chain.getBlock(blockHash);
            return block.block.extrinsics.map((e) => e.hash.toHex());
        };
        this._parseTxAtBlock = async (blockHash, targetTx) => {
            const [block, blockEvents] = await Promise.all([
                this.api.rpc.chain.getBlock(blockHash),
                this.queryStorage('system.events', [], blockHash)
            ]);
            const { transactionHash, transactionIndex, extrinsicIndex, isExtrinsicFailed } = (0, utils_1.getTransactionIndexAndHash)(targetTx, block.block.extrinsics, blockEvents);
            const extrinsicEvents = blockEvents.filter((event) => event.phase.isApplyExtrinsic && event.phase.asApplyExtrinsic.toNumber() === extrinsicIndex);
            return {
                extrinsic: block.block.extrinsics[extrinsicIndex],
                extrinsicEvents: extrinsicEvents,
                transactionHash,
                transactionIndex,
                isExtrinsicFailed
            };
        };
        this.getTransactionReceiptAtBlock = async (hashOrNumber, _blockTag) => {
            const blockTag = await this._ensureSafeModeBlockTagFinalization(_blockTag);
            hashOrNumber = await hashOrNumber;
            const header = await this._getBlockHeader(blockTag);
            const blockHash = header.hash.toHex();
            const blockNumber = header.number.toNumber();
            const { extrinsic, extrinsicEvents, transactionIndex, transactionHash, isExtrinsicFailed } = await this._parseTxAtBlock(blockHash, hashOrNumber);
            const systemEvent = extrinsicEvents.find((event) => ['ExtrinsicSuccess', 'ExtrinsicFailed'].includes(event.event.method));
            if (!systemEvent) {
                return utils_1.logger.throwError('<getTransactionReceiptAtBlock> find system event failed', logger_1.Logger.errors.UNKNOWN_ERROR, {
                    hash: transactionHash,
                    blockHash
                });
            }
            if (isExtrinsicFailed) {
                const [dispatchError] = extrinsicEvents[extrinsicEvents.length - 1].event.data;
                let message = dispatchError.type;
                if (dispatchError.isModule) {
                    try {
                        const mod = dispatchError.asModule;
                        const error = this.api.registry.findMetaError(new Uint8Array([mod.index.toNumber(), mod.error.toNumber()]));
                        message = `${error.section}.${error.name}: ${error.docs}`;
                    }
                    catch (error) {
                        // swallow
                    }
                }
                return utils_1.logger.throwError(`ExtrinsicFailed: ${message}`, logger_1.Logger.errors.UNKNOWN_ERROR, {
                    hash: transactionHash,
                    blockHash
                });
            }
            const { weight: actualWeight } = systemEvent.event.data.toJSON()[0];
            // TODO: deal with multiple events
            const evmEvent = (0, utils_1.findEvmEvent)(extrinsicEvents);
            if (!evmEvent) {
                return utils_1.logger.throwError('findEvmEvent failed', logger_1.Logger.errors.UNKNOWN_ERROR, {
                    blockNumber,
                    tx: hashOrNumber
                });
            }
            // TODO: `getEffectiveGasPrice` and `getPartialTransactionReceipt` can potentially be merged and refactored
            const effectiveGasPrice = await (0, utils_1.getEffectiveGasPrice)(evmEvent, this.api, blockHash, extrinsic, actualWeight);
            const partialTransactionReceipt = (0, utils_1.getPartialTransactionReceipt)(evmEvent);
            const transactionInfo = { transactionIndex, blockHash, transactionHash, blockNumber };
            // to and contractAddress may be undefined
            return this.formatter.receipt({
                effectiveGasPrice,
                confirmations: (await this._getBlockHeader('latest')).number.toNumber() - blockNumber,
                ...transactionInfo,
                ...partialTransactionReceipt,
                logs: partialTransactionReceipt.logs.map((log) => ({
                    ...transactionInfo,
                    ...log
                }))
            });
        };
        this._getTxReceiptFromCache = async (txHash) => {
            const targetBlockNumber = this.localMode
                ? await (0, utils_1.runWithRetries)(this._cache.getBlockNumber.bind(this._cache), [txHash])
                : this._cache?.getBlockNumber(txHash);
            if (!targetBlockNumber)
                return null;
            const targetBlockHash = this.localMode
                ? await (0, utils_1.runWithRetries)(async () => this.api.rpc.chain.getBlockHash(targetBlockNumber))
                : await this.api.rpc.chain.getBlockHash(targetBlockNumber);
            return this.getTransactionReceiptAtBlock(txHash, targetBlockHash.toHex());
        };
        // TODO: test pending
        this._getPendingTX = async (txHash) => {
            const pendingExtrinsics = await this.api.rpc.author.pendingExtrinsics();
            const targetExtrinsic = pendingExtrinsics.find((e) => e.hash.toHex() === txHash);
            if (!(targetExtrinsic && (0, utils_1.isEVMExtrinsic)(targetExtrinsic)))
                return null;
            return {
                from: await this.getEvmAddress(targetExtrinsic.signer.toString()),
                blockHash: null,
                blockNumber: null,
                transactionIndex: null,
                hash: txHash,
                gasPrice: 0,
                ...(0, utils_1.parseExtrinsic)(targetExtrinsic)
            };
        };
        this._getMinedTXReceipt = async (txHash) => {
            const txFromCache = await this._getTxReceiptFromCache(txHash);
            if (txFromCache)
                return txFromCache;
            const txFromSubql = await this.subql?.getTxReceiptByHash(txHash);
            const res = txFromSubql || null;
            if (res) {
                res.blockNumber = +res.blockNumber;
                res.transactionIndex = +res.transactionIndex;
                res.gasUsed = ethers_1.BigNumber.from(res.gasUsed);
                // res.effectiveGasPrice = BigNumber.from(res.effectiveGasPrice);
                // TODO: this is a temp workaround since subquery can't query the prev block
                // and the effectiveGasPrice calculated is a little bit off
                // after subql works we can remove this line
                res.effectiveGasPrice = (await this.getTransactionReceiptAtBlock(res.transactionHash, res.blockNumber)).effectiveGasPrice;
            }
            return res;
        };
        // Queries
        this.getTransaction = (txHash) => (0, utils_1.throwNotImplemented)('getTransaction (deprecated: please use getTransactionByHash)');
        this.getTransactionByHash = async (txHash) => {
            if (!this.localMode) {
                // local mode is for local instant-sealing node
                // so ignore pending tx to avoid some timing issue
                const pendingTX = await this._getPendingTX(txHash);
                if (pendingTX)
                    return pendingTX;
            }
            const tx = await this._getMinedTXReceipt(txHash);
            if (!tx)
                return null;
            const { extrinsic } = await this._parseTxAtBlock(tx.blockHash, txHash);
            return {
                blockHash: tx.blockHash,
                blockNumber: tx.blockNumber,
                transactionIndex: tx.transactionIndex,
                hash: tx.transactionHash,
                from: tx.from,
                gasPrice: tx.effectiveGasPrice,
                ...(0, utils_1.parseExtrinsic)(extrinsic)
                // TODO: can use actual gas from receipt instead of provided gas from parseExtrinsic for consistency
                // gas: tx.gasUsed,
            };
        };
        this.getTransactionReceipt = async (txHash) => (0, utils_1.throwNotImplemented)('getTransactionReceipt (please use `getTXReceiptByHash` instead)');
        this.getTXReceiptByHash = async (txHash) => {
            const tx = await this._getMinedTXReceipt(txHash);
            if (!tx)
                return null;
            return this.formatter.receipt({
                to: tx.to || null,
                from: tx.from,
                contractAddress: tx.contractAddress || null,
                transactionIndex: tx.transactionIndex,
                gasUsed: tx.gasUsed,
                logsBloom: tx.logsBloom,
                blockHash: tx.blockHash,
                transactionHash: tx.transactionHash,
                logs: Array.isArray(tx.logs) ? tx.logs : tx.logs.nodes,
                blockNumber: tx.blockNumber,
                cumulativeGasUsed: tx.cumulativeGasUsed,
                type: tx.type,
                status: tx.status,
                effectiveGasPrice: tx.effectiveGasPrice,
                confirmations: (await this._getBlockHeader('latest')).number.toNumber() - tx.blockNumber
            });
        };
        this._getBlockNumberFromTag = async (blockTag) => {
            switch (blockTag) {
                case 'pending': {
                    return utils_1.logger.throwError('pending tag not implemented', logger_1.Logger.errors.UNSUPPORTED_OPERATION);
                }
                case 'latest': {
                    const header = await this.api.rpc.chain.getHeader();
                    return header.number.toNumber();
                }
                case 'earliest': {
                    return 0;
                }
                default: {
                    if ((0, bytes_1.isHexString)(blockTag) || typeof blockTag === 'number') {
                        return ethers_1.BigNumber.from(blockTag).toNumber();
                    }
                    return utils_1.logger.throwArgumentError("blocktag should be number | hex string | 'latest' | 'earliest'", 'blockTag', blockTag);
                }
            }
        };
        // Bloom-filter Queries
        this.getLogs = async (rawFilter) => {
            if (!this.subql) {
                return utils_1.logger.throwError('missing subql url to fetch logs, to initialize base provider with subql, please provide a subqlUrl param.');
            }
            const { fromBlock, toBlock, blockHash } = rawFilter;
            const filter = { ...rawFilter };
            if (blockHash && (fromBlock || toBlock)) {
                return utils_1.logger.throwError('`fromBlock` and `toBlock` is not allowed in params when `blockHash` is present', logger_1.Logger.errors.INVALID_ARGUMENT, {
                    blockHash,
                    fromBlock,
                    toBlock
                });
            }
            if (blockHash) {
                const blockNumber = (await this._getBlockHeader(blockHash)).number.toNumber();
                filter.fromBlock = blockNumber;
                filter.toBlock = blockNumber;
            }
            else {
                const fromBlockNumber = await this._getBlockNumberFromTag(fromBlock ?? 'latest');
                const toBlockNumber = await this._getBlockNumberFromTag(toBlock ?? 'latest');
                filter.fromBlock = fromBlockNumber;
                filter.toBlock = toBlockNumber;
            }
            const filteredLogs = await this.subql.getFilteredLogs(filter);
            return filteredLogs.map((log) => this.formatter.filterLog(log));
        };
        this.getIndexerMetadata = async () => {
            return await this.subql?.getIndexerMetadata();
        };
        this.getCachInfo = () => this._cache?._inspect();
        this._timeEthCalls = async () => {
            const gasPricePromise = (0, utils_1.runWithTiming)(async () => this.getGasPrice());
            const estimateGasPromise = (0, utils_1.runWithTiming)(async () => this.estimateGas({
                from: '0xe3234f433914d4cfcf846491ec5a7831ab9f0bb3',
                value: '0x0',
                gasPrice: '0x2f0276000a',
                data: '0x',
                to: '0x22293227a254a481883ca5e823023633308cb9ca'
            }));
            // ideally pastNblock should have EVM TX
            const pastNblock = this.latestFinalizedBlockNumber > this._healthCheckBlockDistance
                ? this.latestFinalizedBlockNumber - this._healthCheckBlockDistance
                : this.latestFinalizedBlockNumber;
            const getBlockPromise = (0, utils_1.runWithTiming)(async () => this.getBlockData(pastNblock, false));
            const getFullBlockPromise = (0, utils_1.runWithTiming)(async () => this.getBlockData(pastNblock, true));
            const [gasPriceTime, estimateGasTime, getBlockTime, getFullBlockTime] = (await Promise.all([gasPricePromise, estimateGasPromise, getBlockPromise, getFullBlockPromise])).map((res) => Math.floor(res.time));
            return {
                gasPriceTime,
                estimateGasTime,
                getBlockTime,
                getFullBlockTime
            };
        };
        this.healthCheck = async () => {
            const [indexerMeta, ethCallTiming] = await Promise.all([this.getIndexerMetadata(), this._timeEthCalls()]);
            const cacheInfo = this.getCachInfo();
            const curFinalizedHeight = this.latestFinalizedBlockNumber;
            return (0, utils_1.getHealthResult)({
                indexerMeta,
                cacheInfo,
                curFinalizedHeight,
                ethCallTiming
            });
        };
        // ENS
        this.lookupAddress = (address) => (0, utils_1.throwNotImplemented)('lookupAddress');
        this.waitForTransaction = (transactionHash, confirmations, timeout) => (0, utils_1.throwNotImplemented)('waitForTransaction');
        // Event Emitter (ish)
        this.addEventListener = (eventName, listener, filter) => {
            const id = ethers_1.Wallet.createRandom().address;
            const eventCallBack = (data) => listener({
                subscription: id,
                result: data
            });
            this._listeners[eventName] = this._listeners[eventName] || [];
            this._listeners[eventName].push({ cb: eventCallBack, filter, id });
            return id;
        };
        this.removeEventListener = (id) => {
            ALL_EVENTS.forEach((e) => {
                this._listeners[e] = this._listeners[e]?.filter((l) => l.id !== id);
            });
            return true;
        };
        this.on = (eventName, listener) => (0, utils_1.throwNotImplemented)('on');
        this.once = (eventName, listener) => (0, utils_1.throwNotImplemented)('once');
        this.emit = (eventName, ...args) => (0, utils_1.throwNotImplemented)('emit');
        this.listenerCount = (eventName) => (0, utils_1.throwNotImplemented)('listenerCount');
        this.listeners = (eventName) => (0, utils_1.throwNotImplemented)('listeners');
        this.off = (eventName, listener) => (0, utils_1.throwNotImplemented)('off');
        this.removeAllListeners = (eventName) => (0, utils_1.throwNotImplemented)('removeAllListeners');
        this.formatter = new providers_1.Formatter();
        this._listeners = {};
        this._newBlockListeners = [];
        this.safeMode = safeMode;
        this.localMode = localMode;
        this.verbose = verbose;
        this.latestFinalizedBlockHash = undefined;
        this.latestFinalizedBlockNumber = undefined;
        this.maxBlockCacheSize = maxBlockCacheSize;
        this._storageCache = new lru_cache_1.default({ max: storageCacheSize });
        this._healthCheckBlockDistance = healthCheckBlockDistance;
        safeMode && utils_1.logger.warn(consts_1.SAFE_MODE_WARNING_MSG);
        this.verbose && utils_1.logger.warn(localMode ? consts_1.LOCAL_MODE_MSG : consts_1.PROD_MODE_MSG);
        if (subqlUrl) {
            this.subql = new subqlProvider_1.SubqlProvider(subqlUrl);
        }
    }
    get api() {
        if (!this._api) {
            return utils_1.logger.throwError('the api needs to be set', logger_1.Logger.errors.UNKNOWN_ERROR);
        }
        return this._api;
    }
    get genesisHash() {
        return this.api.genesisHash.toHex();
    }
    get isConnected() {
        return this.api.isConnected;
    }
    get chainDecimal() {
        return this.api.registry.chainDecimals[0] || 10;
    }
    get isSafeMode() {
        return this.safeMode;
    }
    static isProvider(value) {
        return !!(value && value._isProvider);
    }
}
exports.BaseProvider = BaseProvider;
//# sourceMappingURL=base-provider.js.map