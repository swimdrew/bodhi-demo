"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEffectiveGasPrice = exports.parseExtrinsic = exports.getTransactionIndexAndHash = exports.findEvmEvent = exports.getEvmExtrinsicIndexes = exports.getPartialTransactionReceipt = exports.getPartialLogs = exports.getPartialLog = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const bytes_1 = require("@ethersproject/bytes");
const logger_1 = require("@ethersproject/logger");
const consts_1 = require("../consts");
const logger_2 = require("./logger");
const utils_1 = require("./utils");
const getPartialLog = (evmLog, logIndex) => {
    return {
        removed: false,
        address: evmLog.address.toString().toLowerCase(),
        data: evmLog.data.toString().toLowerCase(),
        topics: evmLog.topics.toJSON(),
        logIndex: logIndex
    };
};
exports.getPartialLog = getPartialLog;
const getPartialLogs = (evmLogs) => {
    return evmLogs.map((log, index) => (0, exports.getPartialLog)(log, index));
};
exports.getPartialLogs = getPartialLogs;
const DUMMY_LOGS_BLOOM = '0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';
const getPartialTransactionReceipt = (event) => {
    // @TODO
    const defaultValue = {
        logsBloom: DUMMY_LOGS_BLOOM,
        byzantium: false,
        // @TODO EIP712
        type: 0,
        cumulativeGasUsed: consts_1.BIGNUMBER_ZERO
    };
    switch (event.event.method) {
        case 'Created': {
            const [source, evmAddress, logs, usedGas] = event.event.data;
            return {
                to: undefined,
                from: source.toHex(),
                contractAddress: evmAddress.toString(),
                gasUsed: bignumber_1.BigNumber.from(usedGas?.toString() || 0),
                status: 1,
                logs: (0, exports.getPartialLogs)(logs),
                ...defaultValue
            };
        }
        case 'Executed': {
            const [source, evmAddress, logs, usedGas] = event.event.data;
            return {
                to: evmAddress.toString(),
                from: source.toHex(),
                contractAddress: undefined,
                gasUsed: bignumber_1.BigNumber.from(usedGas?.toString() || 0),
                logs: (0, exports.getPartialLogs)(logs),
                status: 1,
                ...defaultValue
            };
        }
        case 'CreatedFailed': {
            const [source, evmAddress, _exitReason, logs, usedGas] = event.event.data;
            return {
                to: undefined,
                from: source.toHex(),
                contractAddress: evmAddress.toString(),
                gasUsed: bignumber_1.BigNumber.from(usedGas?.toString() || 0),
                logs: (0, exports.getPartialLogs)(logs),
                status: 0,
                exitReason: _exitReason.toString(),
                ...defaultValue
            };
        }
        case 'ExecutedFailed': {
            const [source, evmAddress, _exitReason, , logs, usedGas] = event.event.data;
            return {
                to: evmAddress.toString(),
                from: source.toHex(),
                contractAddress: undefined,
                gasUsed: bignumber_1.BigNumber.from(usedGas?.toString() || 0),
                status: 0,
                exitReason: _exitReason.toString(),
                logs: (0, exports.getPartialLogs)(logs),
                ...defaultValue
            };
        }
    }
    return logger_2.logger.throwError(`unsupported event: ${event.event.method}`);
};
exports.getPartialTransactionReceipt = getPartialTransactionReceipt;
const getEvmExtrinsicIndexes = (events) => {
    return events
        .filter((event) => event.phase.isApplyExtrinsic &&
        event.event.section.toUpperCase() === 'EVM' &&
        ['Created', 'CreatedFailed', 'Executed', 'ExecutedFailed'].includes(event.event.method))
        .reduce((r, event) => {
        const extrinsicIndex = event.phase.asApplyExtrinsic.toNumber();
        if (!r.length) {
            r = [extrinsicIndex];
        }
        else if (r[r.length - 1] !== extrinsicIndex) {
            r.push(extrinsicIndex);
        }
        return r;
    }, []);
};
exports.getEvmExtrinsicIndexes = getEvmExtrinsicIndexes;
const findEvmEvent = (events) => {
    // For the moment the case of multiple evm events in one transaction is ignored
    return events.find(({ event }) => {
        return (event.section.toUpperCase() === 'EVM' &&
            ['Created', 'CreatedFailed', 'Executed', 'ExecutedFailed'].includes(event.method));
    });
};
exports.findEvmEvent = findEvmEvent;
const getTransactionIndexAndHash = (hashOrNumber, extrinsics, events) => {
    const evmExtrinsicIndexes = (0, exports.getEvmExtrinsicIndexes)(events);
    const extrinsicsHashes = extrinsics.map((extrinsic) => extrinsic.hash.toHex());
    let extrinsicIndex = undefined;
    if ((0, bytes_1.isHexString)(hashOrNumber, 32)) {
        extrinsicIndex = extrinsicsHashes.findIndex((hash) => hashOrNumber === hash);
    }
    else {
        const index = bignumber_1.BigNumber.from(hashOrNumber).toNumber();
        extrinsicIndex = evmExtrinsicIndexes[index];
    }
    const transactionHash = extrinsicIndex ? extrinsics[extrinsicIndex]?.hash.toHex() : undefined;
    if (extrinsicIndex === undefined || transactionHash === undefined || extrinsicIndex < 0) {
        return logger_2.logger.throwError(`transaction hash not found`, logger_1.Logger.errors.UNKNOWN_ERROR, {
            hashOrNumber
        });
    }
    const transactionIndex = evmExtrinsicIndexes.findIndex((index) => index === extrinsicIndex);
    if (transactionIndex < 0) {
        return logger_2.logger.throwError(`expected extrinsic include evm events`, logger_1.Logger.errors.UNKNOWN_ERROR, {
            hashOrNumber
        });
    }
    const isExtrinsicFailed = events[events.length - 1].event.method === 'ExtrinsicFailed';
    return {
        transactionIndex,
        transactionHash,
        extrinsicIndex,
        isExtrinsicFailed
    };
};
exports.getTransactionIndexAndHash = getTransactionIndexAndHash;
// parse info that can be extracted from extrinsic alone
const parseExtrinsic = (extrinsic) => {
    // TODO: get correct V_R_S
    const DUMMY_V_R_S = {
        v: consts_1.DUMMY_V,
        r: consts_1.DUMMY_R,
        s: consts_1.DUMMY_S
    };
    const nonce = extrinsic.nonce.toNumber();
    const NONE_EVM_TX_DEFAULT_DATA = {
        value: '0x',
        gas: 2100000,
        input: '0x',
        to: null,
        nonce,
        ...DUMMY_V_R_S
    };
    if (extrinsic.method.section.toUpperCase() !== 'EVM') {
        return NONE_EVM_TX_DEFAULT_DATA;
    }
    const args = extrinsic.method.toJSON().args;
    return {
        value: (0, bytes_1.hexValue)(args.value || 0),
        gas: args.gas_limit || 0,
        input: args.input || args.init || '0x',
        to: args.action?.call || args.target || null,
        nonce,
        ...DUMMY_V_R_S
    };
};
exports.parseExtrinsic = parseExtrinsic;
const getEffectiveGasPrice = async (evmEvent, api, blockHash, extrinsic, actualWeight) => {
    const { data: eventData, method: eventMethod } = evmEvent.event;
    const gasInfoExists = eventData.length > 5 || (eventData.length === 5 && ['Created', 'Executed'].includes(eventMethod));
    if (!gasInfoExists)
        return consts_1.BIGNUMBER_ONE;
    const usedGas = bignumber_1.BigNumber.from(eventData[eventData.length - 2].toString());
    const usedStorage = bignumber_1.BigNumber.from(eventData[eventData.length - 1].toString());
    const block = await api.rpc.chain.getBlock(blockHash);
    // use parentHash to get tx fee
    const parentHash = block.block.header.parentHash;
    const { weight: estimatedWeight } = await api.rpc.payment.queryInfo(extrinsic.toHex(), parentHash);
    const { inclusionFee } = await api.rpc.payment.queryFeeDetails(extrinsic.toHex(), parentHash);
    const { baseFee, lenFee, adjustedWeightFee } = inclusionFee.unwrap();
    const weightFee = (adjustedWeightFee.toBigInt() * BigInt(actualWeight)) / estimatedWeight.toBigInt();
    let txFee = bignumber_1.BigNumber.from(baseFee.toBigInt() + lenFee.toBigInt() + weightFee);
    txFee = (0, utils_1.nativeToEthDecimal)(txFee, 12);
    // if usedStorage > 0, txFee include the storage fee.
    if (usedStorage.gt(0)) {
        const storageFee = usedStorage.mul(api.consts.evm.storageDepositPerByte.toBigInt());
        txFee = txFee.add(storageFee);
    }
    return txFee.div(usedGas);
};
exports.getEffectiveGasPrice = getEffectiveGasPrice;
//# sourceMappingURL=transactionReceiptHelper.js.map