"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nativeToEthDecimal = exports.runWithTiming = exports.getHealthResult = exports.runWithRetries = exports.isEVMExtrinsic = exports.sleep = void 0;
const ethers_1 = require("ethers");
const sleep = (interval = 1000) => new Promise((resolve) => setTimeout(() => resolve(null), interval));
exports.sleep = sleep;
const isEVMExtrinsic = (e) => e.method.section.toUpperCase() === 'EVM';
exports.isEVMExtrinsic = isEVMExtrinsic;
const runWithRetries = async (fn, args = [], maxRetries = 200, interval = 100) => {
    let res;
    let tries = 0;
    while (!res && tries++ < maxRetries) {
        try {
            res = await fn(...args);
        }
        catch (e) {
            if (tries === maxRetries)
                throw e;
        }
        if ((tries === 1 || tries % 10 === 0) && !res) {
            console.log(`<local mode runWithRetries> still waiting for result # ${tries}/${maxRetries}`);
        }
        await (0, exports.sleep)(interval);
    }
    return res;
};
exports.runWithRetries = runWithRetries;
const getHealthResult = ({ indexerMeta, cacheInfo, curFinalizedHeight, ethCallTiming }) => {
    const MAX_IDLE_TIME = 30 * 60; // half an hour
    const MAX_IDLE_BLOCKS = 50; // ~10 minutes
    const ETH_CALL_MAX_TIME = 5000; // 5 seconds
    let isHealthy = true;
    let isSubqlOK = true;
    let isCacheOK = true;
    let isRPCOK = true;
    const msg = [];
    /* --------------- cache --------------- */
    const maxCachedBlocks = cacheInfo?.maxCachedBlocks || 0;
    let cachedBlocksCount = 0;
    if (!cacheInfo) {
        msg.push('no cache running!');
        isHealthy = false;
        isCacheOK = false;
    }
    else {
        cachedBlocksCount = cacheInfo.cachedBlocksCount;
        // only care if at least 1000
        if (cachedBlocksCount > Math.max(1000, Math.floor(maxCachedBlocks * 1.3))) {
            msg.push(`cached blocks size is bigger than expected: ${cachedBlocksCount}, expect at most ~${maxCachedBlocks}`);
            isHealthy = false;
            isCacheOK = false;
        }
    }
    /* --------------- subql --------------- */
    // lastProcessedTimestamp seems to be delayed for a little bit, but it's OK
    const lastProcessedTimestamp = parseInt(indexerMeta?.lastProcessedTimestamp || '0');
    const lastProcessedHeight = indexerMeta?.lastProcessedHeight || 0;
    const targetHeight = indexerMeta?.targetHeight || 0;
    const indexerHealthy = indexerMeta?.indexerHealthy || false;
    const curTimestamp = Date.now();
    const idleTime = (curTimestamp - lastProcessedTimestamp) / 1000;
    const idleBlocks = curFinalizedHeight - Number(lastProcessedHeight);
    if (!indexerMeta) {
        msg.push('no indexer is running!');
        isHealthy = false;
        isSubqlOK = false;
    }
    else {
        if (idleTime > MAX_IDLE_TIME) {
            const idleMinutes = Math.floor(idleTime / 60);
            const idleHours = (idleTime / 3600).toFixed(1);
            msg.push(`indexer already idle for: ${idleTime} seconds = ${idleMinutes} minutes = ${idleHours} hours`);
            isHealthy = false;
            isSubqlOK = false;
        }
        if (idleBlocks > MAX_IDLE_BLOCKS) {
            msg.push(`indexer already idle for: ${idleBlocks} blocks`);
            isHealthy = false;
            isSubqlOK = false;
        }
    }
    /* --------------- RPC --------------- */
    Object.values(ethCallTiming).forEach((t) => {
        if (t > ETH_CALL_MAX_TIME) {
            msg.push(`an RPC is getting slow, takes more than ${ETH_CALL_MAX_TIME / 1000} seconds to complete internally. All timings: ${JSON.stringify(ethCallTiming)}`);
            isHealthy = false;
            isRPCOK = false;
        }
        if (t === -1) {
            msg.push(`an RPC is getting running errors. All timings: ${JSON.stringify(ethCallTiming)}`);
            isHealthy = false;
            isRPCOK = false;
        }
        if (t === -999) {
            msg.push(`an RPC is getting timeouts. All timings: ${JSON.stringify(ethCallTiming)}`);
            isHealthy = false;
            isRPCOK = false;
        }
    });
    /* --------------- result --------------- */
    return {
        isHealthy,
        isSubqlOK,
        isCacheOK,
        isRPCOK,
        msg,
        moreInfo: {
            // cache
            cachedBlocksCount,
            maxCachedBlocksCount: maxCachedBlocks,
            // subql
            lastProcessedHeight,
            targetHeight,
            curFinalizedHeight,
            lastProcessedTimestamp,
            curTimestamp,
            idleSeconds: idleTime,
            idleBlocks,
            indexerHealthy,
            // RPC
            ethCallTiming
        }
    };
};
exports.getHealthResult = getHealthResult;
const TIME_OUT = 20000; // 20s
const runWithTiming = async (fn, repeats = 3) => {
    let res = null;
    const t0 = performance.now();
    let runningErr = false;
    let timedout = false;
    try {
        for (let i = 0; i < repeats; i++) {
            res = await Promise.race([fn(), (0, exports.sleep)(TIME_OUT)]);
            // fn should always return something
            if (res === null) {
                res = `error in runWithTiming: timeout after ${TIME_OUT / 1000} seconds`;
                timedout = true;
                break;
            }
        }
    }
    catch (e) {
        res = `error in runWithTiming: ${e.toString()}`;
        runningErr = true;
    }
    const t1 = performance.now();
    const time = runningErr ? -1 : timedout ? -999 : (t1 - t0) / repeats;
    return {
        res,
        time
    };
};
exports.runWithTiming = runWithTiming;
const ETH_DECIMALS = 18;
const nativeToEthDecimal = (value, nativeDecimals = 12) => ethers_1.BigNumber.from(value).mul(10 ** (ETH_DECIMALS - nativeDecimals));
exports.nativeToEthDecimal = nativeToEthDecimal;
//# sourceMappingURL=utils.js.map