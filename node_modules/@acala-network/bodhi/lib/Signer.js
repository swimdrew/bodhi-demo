"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Signer = exports.logger = void 0;
const lib_1 = require("@acala-network/eth-providers/lib");
const abstract_signer_1 = require("@ethersproject/abstract-signer");
const address_1 = require("@ethersproject/address");
const bignumber_1 = require("@ethersproject/bignumber");
const bytes_1 = require("@ethersproject/bytes");
const logger_1 = require("@ethersproject/logger");
const properties_1 = require("@ethersproject/properties");
const strings_1 = require("@ethersproject/strings");
const util_1 = require("@polkadot/util");
const util_crypto_1 = require("@polkadot/util-crypto");
const utils_1 = require("./utils");
const _version_1 = require("./_version");
exports.logger = new logger_1.Logger(_version_1.version);
class Signer extends abstract_signer_1.Signer {
    constructor(provider, address, signingKey) {
        super();
        (0, properties_1.defineReadOnly)(this, 'provider', provider);
        (0, properties_1.defineReadOnly)(this, 'signingKey', signingKey);
        // @ts-ignore
        this.provider.api.setSigner(signingKey);
        if (typeof address === 'string' && (0, util_crypto_1.isEthereumAddress)(address)) {
            exports.logger.throwError('expect substrate address');
        }
        else {
            try {
                (0, util_crypto_1.decodeAddress)(address);
                (0, properties_1.defineReadOnly)(this, '_substrateAddress', address);
            }
            catch {
                exports.logger.throwArgumentError('invalid address', 'address', address);
            }
        }
    }
    connect(provider) {
        return exports.logger.throwError('cannot alter JSON-RPC Signer connection', logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: 'connect'
        });
    }
    /**
     *
     * @param evmAddress The EVM address to check
     * @returns A promise that resolves to true if the EVM address is claimed
     * or false if the address is not claimed
     */
    async isClaimed(evmAddress) {
        const rpcEvmAddress = await this.queryEvmAddress();
        if (!rpcEvmAddress)
            return false;
        if (!evmAddress)
            return true;
        if (rpcEvmAddress === evmAddress) {
            return true;
        }
        return exports.logger.throwError('An evm account already exists to bind to this account');
    }
    /**
     * Get the signer's EVM address, and claim an EVM address if it has not claimed one.
     * @returns A promise resolving to the EVM address of the signer's substrate
     * address
     */
    async getAddress() {
        const address = await this.queryEvmAddress();
        if (address) {
            return address;
        }
        else {
            // default address
            return this.computeDefaultEvmAddress();
        }
    }
    /**
     * Get the signers EVM address if it has claimed one.
     * @returns A promise resolving to the EVM address of the signer's substrate
     * address or an empty string if the EVM address isn't claimed
     */
    async queryEvmAddress() {
        const address = await this.provider.api.query.evmAccounts.evmAddresses(this._substrateAddress);
        if (!address.isEmpty) {
            const evmAddress = (0, address_1.getAddress)(address.toString());
            return evmAddress;
        }
        return '';
    }
    /**
     *
     * @returns The default EVM address generated for the signer's substrate address
     */
    computeDefaultEvmAddress() {
        const address = this._substrateAddress;
        const publicKey = (0, util_crypto_1.decodeAddress)(address);
        const isStartWithEvm = (0, util_1.u8aEq)('evm:', publicKey.slice(0, 4));
        if (isStartWithEvm) {
            return (0, address_1.getAddress)((0, util_1.u8aToHex)(publicKey.slice(4, 24)));
        }
        return (0, address_1.getAddress)((0, util_1.u8aToHex)((0, util_crypto_1.blake2AsU8a)((0, util_1.u8aConcat)('evm:', publicKey), 256).slice(0, 20)));
    }
    /**
     *
     * @returns The substrate account stored in this Signer
     */
    async getSubstrateAddress() {
        return this._substrateAddress;
    }
    async claimEvmAccount(evmAddress) {
        const isConnented = await this.isClaimed(evmAddress);
        if (isConnented)
            return;
        const publicKey = (0, util_crypto_1.decodeAddress)(this._substrateAddress);
        const data = 'acala evm:' + Buffer.from(publicKey).toString('hex');
        const signature = await this._signMessage(evmAddress, data);
        const extrinsic = this.provider.api.tx.evmAccounts.claimAccount(evmAddress, signature);
        await extrinsic.signAsync(this._substrateAddress);
        await new Promise((resolve, reject) => {
            extrinsic
                .send((result) => {
                (0, lib_1.handleTxResponse)(result, this.provider.api)
                    .then(() => {
                    resolve();
                })
                    .catch((err) => {
                    if (err.message === 'evmAccounts.AccountIdHasMapped') {
                        resolve();
                    }
                    reject(err);
                });
            })
                .catch(reject);
        });
    }
    /**
     * Claims a default EVM address for this signer's substrate address
     */
    async claimDefaultAccount() {
        const extrinsic = this.provider.api.tx.evmAccounts.claimDefaultAccount();
        await extrinsic.signAsync(this._substrateAddress);
        await new Promise((resolve, reject) => {
            extrinsic
                .send((result) => {
                (0, lib_1.handleTxResponse)(result, this.provider.api)
                    .then(() => {
                    resolve();
                })
                    .catch((err) => {
                    if (err.message === 'evmAccounts.AccountIdHasMapped') {
                        resolve();
                    }
                    reject(err);
                });
            })
                .catch((error) => {
                reject(error);
            });
        });
    }
    signTransaction(transaction) {
        return exports.logger.throwError('signing transactions is unsupported', logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: 'signTransaction'
        });
    }
    /**
     *
     * @param transaction
     * @returns A promise that resolves to the transaction's response
     */
    async sendTransaction(_transaction) {
        this._checkProvider('sendTransaction');
        const signerAddress = await this.getSubstrateAddress();
        const evmAddress = await this.getAddress();
        // estimateResources requires the from parameter.
        // However, when creating the contract, there is no from parameter in the tx
        const transaction = {
            from: evmAddress,
            ..._transaction
        };
        const resources = await this.provider.estimateResources(transaction);
        let gasLimit;
        let storageLimit;
        let totalLimit = await transaction.gasLimit;
        if (totalLimit === null || totalLimit === undefined) {
            gasLimit = resources.gas;
            storageLimit = resources.storage;
            totalLimit = resources.gas.add(resources.storage);
        }
        else {
            const estimateTotalLimit = resources.gas.add(resources.storage);
            gasLimit = bignumber_1.BigNumber.from(totalLimit).mul(resources.gas).div(estimateTotalLimit).add(1);
            storageLimit = bignumber_1.BigNumber.from(totalLimit).mul(resources.storage).div(estimateTotalLimit).add(1);
        }
        transaction.gasLimit = totalLimit;
        const tx = await this.populateTransaction(transaction);
        const data = tx.data;
        const from = tx.from;
        if (!data) {
            return exports.logger.throwError('Request data not found');
        }
        if (!from) {
            return exports.logger.throwError('Request from not found');
        }
        let extrinsic;
        // @TODO create contract
        if (!tx.to) {
            extrinsic = this.provider.api.tx.evm.create(tx.data, (0, utils_1.toBN)(tx.value), (0, utils_1.toBN)(gasLimit), (0, utils_1.toBN)(storageLimit.isNegative() ? 0 : storageLimit), tx.accessList || []);
        }
        else {
            extrinsic = this.provider.api.tx.evm.call(tx.to, tx.data, (0, utils_1.toBN)(tx.value), (0, utils_1.toBN)(gasLimit), (0, utils_1.toBN)(storageLimit.isNegative() ? 0 : storageLimit), tx.accessList || []);
        }
        await extrinsic.signAsync(signerAddress);
        return new Promise((resolve, reject) => {
            extrinsic
                .send((result) => {
                (0, lib_1.handleTxResponse)(result, this.provider.api)
                    .then(() => {
                    resolve({
                        hash: extrinsic.hash.toHex(),
                        from: from || '',
                        confirmations: 0,
                        nonce: (0, utils_1.toBN)(tx.nonce).toNumber(),
                        gasLimit: bignumber_1.BigNumber.from(tx.gasLimit || '0'),
                        gasPrice: bignumber_1.BigNumber.from(1),
                        data: (0, utils_1.dataToString)(data),
                        value: bignumber_1.BigNumber.from(tx.value || '0'),
                        chainId: +this.provider.api.consts.evmAccounts.chainId.toString(),
                        wait: (confirmations) => {
                            const hex = result.status.isInBlock
                                ? result.status.asInBlock.toHex()
                                : result.status.asFinalized.toHex();
                            return this.provider.getTransactionReceiptAtBlock(extrinsic.hash.toHex(), hex);
                        }
                    });
                })
                    .catch(reject);
            })
                .catch(reject);
        });
    }
    /**
     *
     * @param message The message to sign
     * @returns A promise that resolves to the signed hash of the message
     */
    async signMessage(message) {
        const evmAddress = await this.queryEvmAddress();
        return this._signMessage(evmAddress, message);
    }
    async _signMessage(evmAddress, message) {
        if (!evmAddress) {
            return exports.logger.throwError('No binding evm address');
        }
        const messagePrefix = '\x19Ethereum Signed Message:\n';
        if (typeof message === 'string') {
            message = (0, strings_1.toUtf8Bytes)(message);
        }
        const msg = (0, util_1.u8aToHex)((0, bytes_1.concat)([(0, strings_1.toUtf8Bytes)(messagePrefix), (0, strings_1.toUtf8Bytes)(String(message.length)), message]));
        if (!this.signingKey.signRaw) {
            return exports.logger.throwError('Need to implement signRaw method');
        }
        const result = await this.signingKey.signRaw({
            address: evmAddress,
            data: msg,
            type: 'bytes'
        });
        return (0, bytes_1.joinSignature)(result.signature);
    }
    async _signTypedData(domain, types, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    value) {
        return exports.logger.throwError('_signTypedData is unsupported', logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: '_signTypedData'
        });
    }
}
exports.Signer = Signer;
//# sourceMappingURL=Signer.js.map