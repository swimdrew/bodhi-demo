"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const wallet_1 = require("@ethersproject/wallet");
const chai_1 = require("chai");
const createTransactionPayload_1 = require("../createTransactionPayload");
const signTransaction_1 = require("../signTransaction");
const transactionHash_1 = require("../transactionHash");
const value = {
    chainId: 595,
    nonce: 0,
    salt: '0x0000000000000000000000000000000000000000000000000000000000000000',
    gasLimit: 2100000,
    to: undefined,
    value: 0,
    data: '0xcfae3217',
    type: 96,
    accessList: []
};
const privateKey = '0x4daddf7d5d2a9059e8065cb3ec50beabe2c23c7d6b3e380c1de8c40269acd85c';
const address = '0xb00cB924ae22b2BBb15E10c17258D6a2af980421';
describe('SignTypedData', () => {
    it('test signature', async () => {
        const payload = (0, createTransactionPayload_1.createTransactionPayload)(value);
        const ethersHash = (0, transactionHash_1.transactionHash)(value);
        const ethersSig = (0, signTransaction_1.signTransaction)(privateKey, value);
        (0, chai_1.expect)((0, wallet_1.verifyTypedData)(payload.domain, {
            AccessList: payload.types.AccessList,
            Transaction: payload.types.Transaction
        }, payload.message, ethersSig)).equal(address);
        // console.log(ethersHash);
        // console.log(ethersSig);
        // const metamaskPayload = {
        //   ...payload,
        //   domain: {
        //     ...payload.domain,
        //     salt: Buffer.from(arrayify(payload.domain.salt))
        //   }
        // };
        // @ts-ignore
        // const metamaskHash = TypedDataUtils.eip712Hash(metamaskPayload, SignTypedDataVersion.V4);
        // const metamaskSig = signTypedData({
        //   privateKey: Buffer.from(arrayify(privateKey)),
        //   data: metamaskPayload,
        //   version: SignTypedDataVersion.V4
        // });
        // console.log(metamaskSig);
        // expect(ethersHash).equal('0x' + metamaskHash.toString('hex'));
        // expect(ethersSig).equal(metamaskSig);
        // expect(
        //   getAddress(
        //     recoverTypedSignature({
        //       data: metamaskPayload,
        //       signature: metamaskSig,
        //       version: SignTypedDataVersion.V4
        //     })
        //   )
        // ).equal(address);
    });
});
//# sourceMappingURL=sign.test.js.map